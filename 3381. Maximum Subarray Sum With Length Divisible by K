#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n) complexity by time and O(k) by space.

I quickly came up with a naive solution, then cursed everything while debugging edge cases, and crashed into TLE. 
I had to think about optimization, O(n * k) isn't fast enough.

Is the correct solution to work beyond the line and based on Kadane's algorithm?
Unfortunately, I couldn't derive it.

I sat with the neural network for about twenty minutes and still didnâ€™t understand how it works. Apparently, today is a bad day to think.
"""

# Solid O(n) solution
# https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/solutions/7363900/maximum-subarray-sum-with-length-divisib-ky9f/?envType=daily-question&envId=2025-11-27
class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        size = len(nums)
        prefixSum = 0
        maxSum = -sys.maxsize
        kSum = [sys.maxsize // 2] * k
        kSum[k - 1] = 0
        for i in range(size):
            prefixSum += nums[i]
            maxSum = max(maxSum, prefixSum - kSum[i % k])
            kSum[i % k] = min(kSum[i % k], prefixSum)
        return maxSum

# Mine cringe TLE 
class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        size = len(nums)
        prefix_sum = [nums[0]]
        max_sum = -math.inf
        for i in range(1, size):
            prefix_sum.append(prefix_sum[-1] + nums[i])
        all_possible_k = [elem for elem in range(1, size + 1) if not elem % k]

        for idx in range(size):
            for step in all_possible_k:
                if idx + step > size:
                    break
                cur_sum = prefix_sum[idx + step - 1] - (prefix_sum[idx - 1] if idx > 0 else 0)
                max_sum = max(max_sum, cur_sum)

        return max_sum
