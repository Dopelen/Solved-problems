#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n) complexity by time and O(1) by space.

I came up with the concept while I was on the subway, and it was right.
Maintain a window of value K and move it around, calculating the maximum profit. 
But it was so hard for me to write it. 
I'm glad it turned out optimal, clear, and beautiful, but it seems some days are much harder to think than others.
"""

class Solution:
    def maxProfit(self, prices: List[int], strategy: List[int], k: int) -> int:
        total_profit = sum([prices[i] * strategy[i] for i in range(len(prices))])
        profit_before_mod = sum([prices[i] * strategy[i] for i in range(k)])
        profit_after_mod = sum([prices[i] * (1 if i >= k // 2 else 0) for i in range(k)])
        best_profit_increase = profit_after_mod - profit_before_mod
        for idx in range(k, len(prices)):
            profit_before_mod -= prices[idx - k] * strategy[idx - k]
            profit_before_mod += prices[idx] * strategy[idx]
            profit_after_mod -= prices[idx - k // 2]
            profit_after_mod += prices[idx]
            best_profit_increase = max(best_profit_increase, profit_after_mod - profit_before_mod)

        return total_profit + max(best_profit_increase, 0)
