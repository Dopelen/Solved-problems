#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode. 
This programm has O(n ** 2) complexity by time and O(n ** 2) by space.

This is a continuation of yesterday's already challenging problem, designed for some very smart people.
The complication is that we now need to find all combinations of points (as yesterday), but in all possible planes, constructing dictionaries of points for each plane if it has more than one parallel line.
And although I was able to give you the concept, I still have no idea how to write it in code.
It seems we should take all possible pairs of points and construct them into a set of functions that will form planes, and add points if they correspond to any of the functions. But I'm not sure.

P.S: My instinct was right. We store points by their "slope" and "offset" between them. If the slope is the same and the offset is different, these lines are parallel.
"""

# https://leetcode.com/problems/count-number-of-trapezoids-ii/solutions/7384426/count-number-of-trapezoids-ii-by-leetcod-3iko/?envType=daily-question&envId=2025-12-03
class Solution:
    def countTrapezoids(self, points: List[List[int]]) -> int:
        size = len(points)
        infinity = 10**9 + 7
        slope_to_intercept = defaultdict(list)
        mid_to_slope = defaultdict(list)
        ans = 0

        for i in range(size):
            x1, y1 = points[i]
            for j in range(i + 1, size):
                x2, y2 = points[j]
                dx = x1 - x2
                dy = y1 - y2

                if x2 == x1:
                    k = infinity
                    b = x1
                else:
                    k = (y2 - y1) / (x2 - x1)
                    b = (y1 * dx - x1 * dy) / dx

                mid = (x1 + x2) * 10000 + (y1 + y2)
                slope_to_intercept[k].append(b)
                mid_to_slope[mid].append(k)

        for sti in slope_to_intercept.values():
            if len(sti) == 1:
                continue

            cnt = defaultdict(int)
            for b_val in sti:
                cnt[b_val] += 1

            total_sum = 0
            for count in cnt.values():
                ans += total_sum * count
                total_sum += count

        for mts in mid_to_slope.values():
            if len(mts) == 1:
                continue

            cnt = defaultdict(int)
            for k_val in mts:
                cnt[k_val] += 1

            total_sum = 0
            for count in cnt.values():
                ans -= total_sum * count
                total_sum += count

        return ans


