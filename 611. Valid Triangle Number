#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This programm has O(n ** 2) comlexity by time and O(max_elem) by space

I remembered geometry lessons and the properties of a triangle from 7th grade and wrote a brute force solution with complexity O(n ** 3) and it (expectedly) did not pass in time, so I had to think again.

Then I thought HARD and fiddled with prefix sums and optimization from O(n **3) to O(n **2) for a whole hour, but I managed it.
"""

# Right solution (O ** 2)
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        size = len(nums)
        if size < 3:
            return 0

        nums.sort()
        max_elem = nums[-1]
        prefix_sum = [0] * (max_elem + 2)

        for num in nums:
            if num <= max_elem:
                prefix_sum[num] += 1

        for i in range(1, max_elem + 2):
            prefix_sum[i] += prefix_sum[i - 1]

        valid_triplets = 0

        for i in range(size):
            for j in range(i + 1, size):
                a, b = nums[i], nums[j]
                max_c = a + b - 1

                if max_c < 0:
                    continue

                if max_c > max_elem:
                    max_c = max_elem

                total_c = prefix_sum[max_c]
                elements_up_to_j = j + 1
                valid_c = total_c - elements_up_to_j

                if valid_c > 0:
                    valid_triplets += valid_c

        return valid_triplets


# MvP Solution (2 pointers)
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        if len(nums) <= 2:
            return 0
        count = 0
        for k in range(2, len(nums)):
            pointer_1, pointer_2 = 0, k - 1
            while pointer_1 < pointer_2:
                if nums[pointer_1] + nums[pointer_2] > nums[k]:
                    count += (pointer_2 - pointer_1)
                    pointer_2 -= 1
                else:
                    pointer_1 += 1
        return count


# Naive O(n ** 3) "solution"
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        size = len(nums)
        valid_combinations = 0
        nums.sort()

        for i in range(size):
            for j in range(i + 1, size):
                for k in range(j + 1, size):
                    if nums[i] + nums[j] > nums[k]:
                        valid_combinations += 1
        return valid_combinations

# If you love list comprehensions
# valid_combinations = sum(nums[i] + nums[j] > nums[k] for i in range(size) for j in range(i + 1, size) for k in range(j + 1, size))
