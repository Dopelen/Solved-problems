#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n * log(n)) complexity by time and O(n) by space.

It's not a very difficult task; the concept is immediately obvious, and then you only need a couple of pauses to figure out how to quickly and easily get the frequencies and values ​​themselves, and whether it's even necessary to do so.
"""

# After refactoring
class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        count = Counter(arr)
        sorted_freq = sorted(count.values(), reverse=True)
        current_freq_sum = 0
        for i, freq in enumerate(sorted_freq, start=1):
            current_freq_sum += freq
            if current_freq_sum * 2 >= len(arr):
                return i


# Initial Solution
class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        count = Counter(arr)
        sorted_freq = sorted(count.items(), key= lambda x: x[1])
        extracted_numbers = extracted_units = 0
        while extracted_numbers < len(arr) // 2:
            num, freq = sorted_freq.pop()
            extracted_numbers += freq
            extracted_units += 1
        return extracted_units
