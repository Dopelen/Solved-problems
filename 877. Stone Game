"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(1) complexity by time and O(1) by space.

For me, the problem turned out to be somewhat confusing, since it cannot be solved by a greedy algorithm, and dynamic programming looks strange.
I found the mathematical logic of the solution, why the first player always wins.
"""

# https://leetcode.com/problems/stone-game/editorial/
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        return True

# Real DP solution
# https://leetcode.com/problems/stone-game/editorial/
class Solution:
    def stoneGame(self, piles):
        N = len(piles)

        @lru_cache(None)
        def dp(i, j):
            # The value of the game [piles[i], piles[i+1], ..., piles[j]].
            if i > j: return 0
            parity = (j - i - N) % 2
            if parity == 1:  # first player
                return max(piles[i] + dp(i+1,j), piles[j] + dp(i,j-1))
            else:
                return min(-piles[i] + dp(i+1,j), -piles[j] + dp(i,j-1))

        return dp(0, N - 1) > 0
