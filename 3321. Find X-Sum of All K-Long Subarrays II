#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n * log(n)) complexity by time and O(n) by space.

We have a sliding window, and as it moves, the frequency maxima in the window change.
Recalculating them at each step is expensive; essentially, we're just swapping one element for another. 
We can actually calculate new frequencies by lowering the frequency of the element that's disappeared from the window and raising the frequency of the new one.
This can be done by recalculating the entire window, but it's time-consuming and won't pass.
We can keep the window in a sorted list—then we can find and change values, but the problem is that we'll need to DELETE and ADD values ​​to the list. 
This reduces the search cost to log n time, but the problem with deleting in n time remains.
So, ultimately, we need to implement a data structure that performs search and deletion in logarithmic time.
This is where the SortedList module, which is based on a B-Tree, comes in.

I understood the concept of the solution myself, but I haven’t been able to write a B-Tree for this problem yet, so here’s the solution from the author.
"""

# https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-ii/solutions/7326249/find-x-sum-of-all-k-long-subarrays-ii-by-a29u/?envType=daily-question&envId=2025-11-05
class Helper:
    def __init__(self, x):
        self.x = x
        self.result = 0
        self.large = SortedList()
        self.small = SortedList()
        self.occ = defaultdict(int)

    def insert(self, num):
        if self.occ[num] > 0:
            self.internal_remove((self.occ[num], num))
        self.occ[num] += 1
        self.internal_insert((self.occ[num], num))

    def remove(self, num):
        self.internal_remove((self.occ[num], num))
        self.occ[num] -= 1
        if self.occ[num] > 0:
            self.internal_insert((self.occ[num], num))

    def get(self):
        return self.result

    def internal_insert(self, p):
        if len(self.large) < self.x or p > self.large[0]:
            self.result += p[0] * p[1]
            self.large.add(p)
            if len(self.large) > self.x:
                to_remove = self.large[0]
                self.result -= to_remove[0] * to_remove[1]
                self.large.remove(to_remove)
                self.small.add(to_remove)
        else:
            self.small.add(p)

    def internal_remove(self, p):
        if p >= self.large[0]:
            self.result -= p[0] * p[1]
            self.large.remove(p)
            if self.small:
                to_add = self.small[-1]
                self.result += to_add[0] * to_add[1]
                self.small.remove(to_add)
                self.large.add(to_add)
        else:
            self.small.remove(p)


class Solution:
    def findXSum(self, nums, k, x):
        helper = Helper(x)
        ans = []

        for i in range(len(nums)):
            helper.insert(nums[i])
            if i >= k:
                helper.remove(nums[i - k])
            if i >= k - 1:
                ans.append(helper.get())

        return ans
