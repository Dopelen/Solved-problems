#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n) complexity by time and O(n) by space.

Three years later, tree problems generally seem very simple.
It seems like level traversal could be written more elegantly, but that's the first thing that came to mind.

When I started programming, dictionaries didn't yet store insertion order, and I couldn't write this so easily :)
"""

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:

        levels = defaultdict(list)

        def traverse(r, level):
            if not r:
                return
            levels[level].append(r.val)
            traverse(r.left, level + 1)
            traverse(r.right, level + 1)

        traverse(root, 0)
        level_order = []
        for key, value in levels.items():
            level_order.append(value)

        return level_order
