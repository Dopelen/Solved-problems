"""You can see the description of the task using the code specified in the title on leetcode.
 This program has O(query_row ** 2) complexity by time and O(1).

I initially wrote an iterative solution, but then I realized I could get by with two adjacent levels, without having to remember the entire champagne pyramid, and the solution turned out to be quite elegant.
The only thing is, I can't shake the feeling that this problem can be solved mathematically for a constant, since we know the distribution.

P.S: We can even keep only half of the pyramid in memory because it is symmetrical.
"""

# After refactoring
class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        cur_level = [poured]
        for _ in range(query_row):
            next_level = [0.0] * (len(cur_level) + 1)
            for idx, elem in enumerate(cur_level):
                liquid_left = max(0, elem - 1)
                next_level[idx] += liquid_left / 2
                next_level[idx + 1] += liquid_left / 2
            cur_level = next_level
        return min(1.0, cur_level[query_glass])


# Initial Solution
class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        cur_level = [poured]
        cur_depth = 0
        while cur_depth < query_row:
            next_level = [0.0] * (cur_depth + 2)
            for idx, elem in enumerate(cur_level):
                liquid_left = max(0, elem - 1)
                next_level[idx] += liquid_left / 2
                next_level[idx + 1] += liquid_left / 2
            cur_level = next_level
            cur_depth += 1
        return cur_level[query_glass] if cur_level[query_glass] < 1 else 1
