#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n)  complexity by time and O(1) by space.

At first, I thought I'd hit a dead end, but after about 15 minutes, it dawned on me.
The first element must be minimal and unique, otherwise we won't be able to decrypt the following elements. 
All that's left is to calculate the combinations for the remaining elements.
And they can be opened in any order, which is a factorial of the array length possible combinations.
"""

class Solution:
    def countPermutations(self, complexity: List[int]) -> int:
        MOD = 10 ** 9 + 7
        min_val = min(complexity)
        if complexity[0] >= min(complexity[1:]):
            return 0

        return math.factorial(len(complexity) - 1) % MOD
