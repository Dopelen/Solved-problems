#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n) complexity by time and O(n) by space.

I started calculating intervals and quickly realized that with negative numbers it might be advantageous to take the "increasing interval" not from the very beginning, which significantly complicates the task.
This forced me to change my approach. 
You can find all the DESCENDING sequences as pivots and check their neighbors to see if they're increasing. 
If they are, take their first two elements, and then the remaining parts based on whether they increase the final sum or not.
Don't forget to remove the first and last elements of a descending sequence, because when forming a segment entirely from sums, they will be counted twice - as part of the ascending and part of the descending segments.
This problem can be avoided by using an array of intervals instead of calculating the sums, but then you will have to do double work - count the intervals, and then go through it a second time to calculate the sums.
"""

class Solution:
    def maxSumTrionic(self, nums: List[int]) -> int:
        """
        (type, total_sum, optimal_from_left, optimal_from_right)
        type: 1 - ASC, 0 - DESC, 2 - None
        total_sum: sum of subarray
        optimal_from_left: minimum = sum of 2 left elements + additional elements which increase sum
        optimal_from_right: minimum = sum of 2 right elements + additional elements which increase sum
        """
        size = len(nums)
        idx = 0
        intervals_sums = []

        def calculate_asc(idx):
            initial_idx = idx
            while idx < size - 1 and nums[idx] < nums[idx + 1]:
                idx += 1
            total_sum = sum(nums[initial_idx:idx + 1])
            left_sum = max(total_sum, sum(nums[initial_idx:initial_idx + 2]))
            right_sum = max(total_sum, sum(nums[idx - 1:idx + 1]) + sum(s for s in nums[initial_idx:max(initial_idx, idx - 1)] if s > 0))
            intervals_sums.append((1, total_sum, left_sum, right_sum))
            return idx

        def calculate_desc(idx):
            initial_idx = idx
            cur_sum = nums[idx]
            while idx < size - 1 and nums[idx] > nums[idx + 1]:
                cur_sum += nums[idx + 1]
                idx += 1
            # When we sum our arrays DESC part will be added twice:
            # bc first elem -> part of previous asc arr and last elem -> part of next asc arr
            intervals_sums.append((0, cur_sum - nums[idx] - nums[initial_idx], 0, 0))
            return idx

        while idx < size - 1:
            if nums[idx] == nums[idx + 1]:
                idx += 1
                intervals_sums.append((2, 0, 0, 0))
                continue
            idx = calculate_asc(idx) if nums[idx] < nums[idx + 1] else calculate_desc(idx)

        total_max = -math.inf
        for i in range(1, len(intervals_sums) - 1):
            if intervals_sums[i][0] in [1, 2]:
                continue
            if intervals_sums[i - 1][0] == intervals_sums[i + 1][0] == 1:
                total_max = max(total_max, intervals_sums[i - 1][3] + intervals_sums[i][1] + intervals_sums[i + 1][2])
        return total_max
