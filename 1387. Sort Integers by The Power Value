#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
So this program has O(n * log(n)) complexity by time and O(n) by space.

When I saw the problem, I thought it would be fairly simple to emulate the process, so I did.
But if you look at the constraints, you'll notice that the K value can only be in the range up to "hi - lo + 1", which hints at some kind of internal pattern. 
It looks like it can be solved without emulation, but I looked at other solutions and didn't find anything similar, so I settled on my cache + sorting.

Counting operations complicates caching, so I had to abandon the out-of-the-box cache and write my own
"""

# Final Solution
class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:
        memo = {}

        def calculate_power(x: int):
            power = 0
            if x in memo:
                return memo[x]
            if x == 1:
                return 0
            if x % 2 == 0:
                memo[x] = 1 + calculate_power(x // 2)
            else:
                memo[x] = 1 + calculate_power(3 * x + 1)
            return memo[x]

        values = [(calculate_power(x), x) for x in range(lo, hi + 1)]
        values.sort()
        return values[k - 1][1]
