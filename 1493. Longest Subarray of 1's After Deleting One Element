#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n) complexity by time and O(1) by space.

It takes exactly 3 minutes to write the code, but debugging takes the next half hour.
"""

# Refactored
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        max_len = current = prev = 0
        
        for num in nums:
            if num == 1:
                current += 1
            else:
                max_len = max(max_len, prev + current)
                prev = current
                current = 0
        
        max_len = max(max_len, prev + current) 
        return max_len if current != len(nums) else current - 1

# Initial Solution
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        current = prev = max_total = 0
        one_zero = False

        def calculate_current_max():
            nonlocal current, prev, max_total
            max_total = max(max_total, current + prev)
            prev = current
            current = 0


        for index in range(len(nums)):
            if nums[index] == 1:
                current += 1
                one_zero = False
            else:
                if one_zero:
                    current = prev = 0
                one_zero = True
                if current != 0:
                    calculate_current_max()

        if current == len(nums):
            return current - 1
        elif nums[-1] == 1:
            calculate_current_max()
        return max_total
