#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode. 
This programm has O(n) complexity by time and O(1) by space.

A fairly simple tree traversal task.
We perform an in-order traversal with a record of the current depth and if we go to a lower level, we record the current value in response. 
Due to the type of traversal, the leftmost value will always be the first on the left when going down to a lower level, and this is exactly what they want from us.
"""

# initial Solution
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        max_depth = -1
        max_val = None

        def traverse(r, d):
            nonlocal max_depth, max_val
            if r is None:
                return
            if max_depth < d:
                max_depth = d
                max_val = r.val
            traverse(r.left, d + 1)
            traverse(r.right, d + 1)

        traverse(root, 0)
        return max_val

# Also can solve it with deque
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        q = deque([root])
        res = 0

        while q:
            node = q.popleft()
            res = node.val
            if node.right:
                q.append(node.right)
            if node.left:
                q.append(node.left)

        return res
