#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n * log(n)) complexity by time and O(n) by space.

A more complex version of yesterday's solution.
I couldn't come up with a beautiful solution in an hour, so I'm sharing with you beautiful solutions from smart people.
"""

# https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/solutions/7291056/clear-explaination-binary-search-c-java-6os8g/
class Solution:
    def check(self, nums, n, t, m):
        nL = n
        tL = t
        l = bisect_left(nums, nL)
        h = bisect_right(nums, nL)
        ll = bisect_left(nums, nL - tL)
        hh = bisect_right(nums, nL + tL)
        res = (hh - h) + (l - ll)
        return min(m, res) + (h - l)

    def maxFrequency(self, nums, k, numOperations):
        m = numOperations
        nums.sort()
        ans = 1
        for i in range(len(nums) - 1):
            ans = max(ans, self.check(nums, nums[i], k, m))
            ans = max(ans, self.check(nums, nums[i] - k, k, m))
            ans = max(ans, self.check(nums, nums[i] + k, k, m))
        return ans


# https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        arrayValMaxFreq = self.maxFrequencyOfArrayVal(nums, k, numOperations)
        left = 0
        otherValMaxFreq = 0
        for right in range(len(nums)):
            while nums[right] > nums[left] + 2 * k:
                left += 1
            otherValMaxFreq = max(otherValMaxFreq, right - left + 1)
            if otherValMaxFreq >= numOperations:
                otherValMaxFreq = numOperations
                break
        return max(arrayValMaxFreq, otherValMaxFreq)

    def maxFrequencyOfArrayVal(self, nums, k, numOperations):
        count = Counter(nums)
        maxFreq = 0
        for val in count.keys():
            left = bisect_left(nums, val - k)
            right = bisect_right(nums, val + k) - 1
            freq = min(right - left + 1, numOperations + count[val])
            maxFreq = max(maxFreq, freq)
        return maxFreq
