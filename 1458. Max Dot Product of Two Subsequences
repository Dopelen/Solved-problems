#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n * n) complexity by time and O(n * n) by space.

At first I thought it would be enough to greedily take pairs regardless of the order, but it turned out to be important, and the problem became more difficult.
The task isn't particularly difficult, but it's tricky.
We consider three transition options: start a new one, continue the old one, or skip.
I was able to figure it out with the hints, but it's still very difficult to understand.
"""

class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        size_1, size_2 = len(nums1), len(nums2)
        dp = [[-math.inf] * size_2 for _ in range(size_1)]
        for i in range(size_1):
            for j in range(size_2):
                prod = nums1[i] * nums2[j]
                best = prod
                if i > 0 and j > 0:
                    best = max(best, dp[i - 1][j - 1] + prod)
                if i > 0:
                    best = max(best, dp[i - 1][j])
                if j > 0:
                    best = max(best, dp[i][j - 1])
                dp[i][j] = best
        return dp[size_1 - 1][size_2 - 1]
