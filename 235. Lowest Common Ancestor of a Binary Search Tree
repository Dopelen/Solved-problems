#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(log(n)) complexity by time and O(1) by space.

A typical problem is finding a common ancestor.
Since we have a search tree, we can simply return the node at the moment when the minimum desired number is in the left subtree and the maximum in the right, or one of them.
"""

# Initial Solution
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        low = min(p.val, q.val)
        high = max(p.val, q.val)

        def dfs(r):
            if low <= r.val <= high:
                return r
            elif r.val < low and r.val < high:
                return dfs(r.right)
            else:
                return dfs(r.left)

        return dfs(root)


# Refactoret (iterative)
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while root:
            if p.val < root.val and q.val < root.val:
                root = root.left
            elif p.val > root.val and q.val > root.val:
                root = root.right
            else:
                return root
