#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n * m * k) complexity by time and O(n * m) by space.

I honestly tried, but I didn't finish it in time, and I can't sit with it for four hours today.
It's solved using a rather unusual dynamic programming approach with grouping.
"""

# https://leetcode.com/problems/minimum-cost-path-with-teleportations/?envType=daily-question&envId=2026-01-28
class Solution:
    def minCost(self, grid: list[list[int]], k: int) -> int:
        height, width = len(grid), len(grid[0])
        points = [(i, j) for i in range(height) for j in range(width)]
        points.sort(key=lambda p: grid[p[0]][p[1]])
        costs = [[float("inf")] * width for _ in range(height)]
        for t in range(k + 1):
            minCost = float("inf")
            j = 0
            for i in range(len(points)):
                minCost = min(minCost, costs[points[i][0]][points[i][1]])
                if (
                    i + 1 < len(points)
                    and grid[points[i][0]][points[i][1]]
                    == grid[points[i + 1][0]][points[i + 1][1]]
                ):
                    i += 1
                    continue
                for r in range(j, i + 1):
                    costs[points[r][0]][points[r][1]] = minCost
                j = i + 1
            for i in range(height - 1, -1, -1):
                for j in range(width - 1, -1, -1):
                    if i == height - 1 and j == width - 1:
                        costs[i][j] = 0
                        continue
                    if i != height - 1:
                        costs[i][j] = min(
                            costs[i][j], costs[i + 1][j] + grid[i + 1][j]
                        )
                    if j != width - 1:
                        costs[i][j] = min(
                            costs[i][j], costs[i][j + 1] + grid[i][j + 1]
                        )
        return costs[0][0]
