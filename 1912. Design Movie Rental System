#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(log(n)) complexity by time and O(n) by space.

It probably took me about 4 hours to do all of this, and I was really stuck on an error with duplicates that occurred when I dropped a record, and its old version remained inside the heap. 
To solve this, I had to introduce an additional set through which I could check the current records inside the heap, but overall I'm happy with the result.
"""

# Mine Heap Solution
class MovieRentingSystem:

    def __init__(self, n: int, entries: List[List[int]]):
        self.in_stock_heap = defaultdict(list)
        self.rented_heap = []
        self.in_stock_set = set()
        self.rented_set = set()

        self.in_stock_heap_presence = set()
        self.rented_heap_presence = set()

        self.shop_movie_to_price = {}
        for shop, movie, price in entries:
            t = (price, shop, movie)
            heappush(self.in_stock_heap[movie], t)
            self.in_stock_heap_presence.add(t)
            self.in_stock_set.add(t)
            self.shop_movie_to_price[(shop, movie)] = price

    def _clean_in_stock_top(self, movie: int):
        heap = self.in_stock_heap[movie]
        while heap and heap[0] not in self.in_stock_set:
            t = heappop(heap)
            if t in self.in_stock_heap_presence:
                self.in_stock_heap_presence.remove(t)

    def _clean_rented_top(self):
        heap = self.rented_heap
        while heap and heap[0] not in self.rented_set:
            t = heappop(heap)
            if t in self.rented_heap_presence:
                self.rented_heap_presence.remove(t)

    def search(self, movie: int) -> List[int]:
        result = []
        processed = []
        self._clean_in_stock_top(movie)

        while len(result) < 5 and self.in_stock_heap[movie]:
            t = heappop(self.in_stock_heap[movie])
            if t in self.in_stock_heap_presence:
                self.in_stock_heap_presence.remove(t)
            if t in self.in_stock_set:
                result.append(t[1])
                processed.append(t)
            self._clean_in_stock_top(movie)

        for t in processed:
            heappush(self.in_stock_heap[movie], t)
            self.in_stock_heap_presence.add(t)

        return result

    def rent(self, shop: int, movie: int) -> None:
        price = self.shop_movie_to_price.get((shop, movie))
        if price is None:
            return
        t = (price, shop, movie)
        if t in self.in_stock_set:
            self.in_stock_set.remove(t)
            self.rented_set.add(t)
            if t not in self.rented_heap_presence:
                heappush(self.rented_heap, t)
                self.rented_heap_presence.add(t)

    def drop(self, shop: int, movie: int) -> None:
        price = self.shop_movie_to_price.get((shop, movie))
        if price is None:
            return
        t = (price, shop, movie)
        if t in self.rented_set:
            self.rented_set.remove(t)
            self.in_stock_set.add(t)
            if t not in self.in_stock_heap_presence:
                heappush(self.in_stock_heap[movie], t)
                self.in_stock_heap_presence.add(t)

    def report(self) -> List[List[int]]:
        result = []
        processed = []

        self._clean_rented_top()

        while len(result) < 5 and self.rented_heap:
            t = heappop(self.rented_heap)
            if t in self.rented_heap_presence:
                self.rented_heap_presence.remove(t)
            if t in self.rented_set:
                result.append([t[1], t[2]])
                processed.append(t)
            self._clean_rented_top()

        for t in processed:
            heappush(self.rented_heap, t)
            self.rented_heap_presence.add(t)

        return result


# Beautifull greed and fast solution
# https://leetcode.com/problems/design-movie-rental-system/solutions/7209446/most-efficient-bineary-search-tree-java-python-c-javascript-beat-100/?envType=daily-question&envId=2025-09-21
class MovieRentingSystem:

    def __init__(self, n: int, entries: List[List[int]]):
        self.available = {}  # (shop, movie) -> price
        self.movie_shops = {}  # movie -> list of (price, shop)
        self.rented = set()  # (shop, movie) that are currently rented

        for shop, movie, price in entries:
            self.available[(shop, movie)] = price
            if movie not in self.movie_shops:
                self.movie_shops[movie] = []
            self.movie_shops[movie].append((price, shop))

        # Sort shops by price for each movie initially
        for movie in self.movie_shops:
            self.movie_shops[movie].sort()

    def search(self, movie: int) -> List[int]:
        result = []
        for price, shop in self.movie_shops.get(movie, []):
            if (shop, movie) not in self.rented:
                result.append(shop)
            if len(result) == 5:
                break
        return result

    def rent(self, shop: int, movie: int) -> None:
        self.rented.add((shop, movie))

    def drop(self, shop: int, movie: int) -> None:
        self.rented.discard((shop, movie))

    def report(self) -> List[List[int]]:
        rented_list = []
        for shop, movie in self.rented:
            price = self.available[(shop, movie)]
            rented_list.append((price, shop, movie))

        rented_list.sort()
        return [[shop, movie] for price, shop, movie in rented_list[:5]]
