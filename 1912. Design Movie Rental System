#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(log(n)) complexity by time and O(n) by space.

It probably took me about 4 hours to do all of this, and I was really stuck on an error with duplicates that occurred when I dropped a record, and its old version remained inside the heap. 
To solve this, I had to introduce an additional set through which I could check the current records inside the heap, but overall I'm happy with the result.
"""

class MovieRentingSystem:

    def __init__(self, n: int, entries: List[List[int]]):
        self.in_stock_heap = defaultdict(list)
        self.rented_heap = []
        self.in_stock_set = set()
        self.rented_set = set()

        self.in_stock_heap_presence = set()
        self.rented_heap_presence = set()

        self.shop_movie_to_price = {}
        for shop, movie, price in entries:
            t = (price, shop, movie)
            heappush(self.in_stock_heap[movie], t)
            self.in_stock_heap_presence.add(t)
            self.in_stock_set.add(t)
            self.shop_movie_to_price[(shop, movie)] = price

    def _clean_in_stock_top(self, movie: int):
        heap = self.in_stock_heap[movie]
        while heap and heap[0] not in self.in_stock_set:
            t = heappop(heap)
            if t in self.in_stock_heap_presence:
                self.in_stock_heap_presence.remove(t)

    def _clean_rented_top(self):
        heap = self.rented_heap
        while heap and heap[0] not in self.rented_set:
            t = heappop(heap)
            if t in self.rented_heap_presence:
                self.rented_heap_presence.remove(t)

    def search(self, movie: int) -> List[int]:
        result = []
        processed = []
        self._clean_in_stock_top(movie)

        while len(result) < 5 and self.in_stock_heap[movie]:
            t = heappop(self.in_stock_heap[movie])
            if t in self.in_stock_heap_presence:
                self.in_stock_heap_presence.remove(t)
            if t in self.in_stock_set:
                result.append(t[1])
                processed.append(t)
            self._clean_in_stock_top(movie)

        for t in processed:
            heappush(self.in_stock_heap[movie], t)
            self.in_stock_heap_presence.add(t)

        return result

    def rent(self, shop: int, movie: int) -> None:
        price = self.shop_movie_to_price.get((shop, movie))
        if price is None:
            return
        t = (price, shop, movie)
        if t in self.in_stock_set:
            self.in_stock_set.remove(t)
            self.rented_set.add(t)
            if t not in self.rented_heap_presence:
                heappush(self.rented_heap, t)
                self.rented_heap_presence.add(t)

    def drop(self, shop: int, movie: int) -> None:
        price = self.shop_movie_to_price.get((shop, movie))
        if price is None:
            return
        t = (price, shop, movie)
        if t in self.rented_set:
            self.rented_set.remove(t)
            self.in_stock_set.add(t)
            if t not in self.in_stock_heap_presence:
                heappush(self.in_stock_heap[movie], t)
                self.in_stock_heap_presence.add(t)

    def report(self) -> List[List[int]]:
        result = []
        processed = []

        self._clean_rented_top()

        while len(result) < 5 and self.rented_heap:
            t = heappop(self.rented_heap)
            if t in self.rented_heap_presence:
                self.rented_heap_presence.remove(t)
            if t in self.rented_set:
                result.append([t[1], t[2]])
                processed.append(t)
            self._clean_rented_top()

        for t in processed:
            heappush(self.rented_heap, t)
            self.rented_heap_presence.add(t)

        return result
