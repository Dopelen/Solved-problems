#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n * k + n ** 2)  complexity by time and O(n) by space.

I almost lost my mind trying to figure this problem out.
The original version was with the calculation of all permutations, but something didn't work out for me with this solution and I went to look for a more optimal way.
Initially, we generate the k-th permutation, and then greedily count the swaps.
Some kind of problem is ridiculous and not very clear, as if it doesnâ€™t even have a beautiful solution.
"""

class Solution:
    def getMinSwaps(self, num: str, k: int) -> int:
        size  = len(num)
        num = list(map(int, num))
        copy_of_num = num[::]

        for _ in range(k):
            i = size - 1
            while i > 0 and copy_of_num[i - 1] >= copy_of_num[i]:
                i -= 1
            if i > 0:
                j = size - 1
                while copy_of_num[j] <= copy_of_num[i - 1]:
                    j -= 1
                copy_of_num[i - 1], copy_of_num[j] = copy_of_num[j], copy_of_num[i - 1]
            copy_of_num[i:] = copy_of_num[size - 1:i - 1:-1]

        i = number_of_swaps = 0
        while i < size:
            j = i
            while copy_of_num[j] != num[i]:
                j += 1

            while i < j:
                copy_of_num[j - 1], copy_of_num[j] = copy_of_num[j], copy_of_num[j - 1]
                j -= 1
                number_of_swaps += 1
            i += 1

        return number_of_swaps
