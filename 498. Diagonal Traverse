#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n * m) complexity by time and O(n * m) by space.

We do a matrix bypass according to the condition.
The most difficult part for me was that I confused the movements by height (y), because - 1 in matrix is up, and + 1 is down :)

P.S: I saw a pattern of movement that repeats itself, and I realized that when moving up and down, the same operations are performed, just in one case with the x coordinate, and in the other with the y.
So I put everything in one function.
I think this solution is bad, because the logic itself is not clear at first glance, why I pass arguments to the function in different orders depending on the direction of movement, but I'm glad I was able to write it.
"""

# One function solution
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        final_list = []
        height, width = len(mat), len(mat[0])
        up = True
        x = y = 0

        def traverse(arg_1, arg_2):
            nonlocal x, y, up
            initial_direction = up
            if (arg_1 - 1 < 0) or (arg_2 + 1 == (width if initial_direction else height)):
                up = not up
                if arg_2 + 1 == (width if initial_direction else height):
                    arg_1 += 1
                else:
                    arg_2 += 1
            else:
                arg_1 -= 1
                arg_2 += 1
            y = arg_1 if initial_direction else arg_2
            x = arg_2 if initial_direction else arg_1

        while y != height and x != width:
            final_list.append(mat[y][x])
            traverse(y if up else x, x if up else y)
        return final_list


# Initial Solution
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        final_list = []
        height, width = len(mat), len(mat[0])
        up = True
        x = y = 0

        while y != height and x != width:
            final_list.append(mat[y][x])
            if up:
                if (y - 1 < 0) or (x + 1 == width):
                    up = not up
                    if x + 1 == width:
                        y += 1
                    else:
                        x += 1
                else:
                    y -= 1
                    x += 1
            else:
                if (x - 1 < 0) or (y + 1 == height):
                    up = not up
                    if y + 1 == height:
                        x += 1
                    else:
                        y += 1
                else:
                    y += 1
                    x -= 1
        return final_list
