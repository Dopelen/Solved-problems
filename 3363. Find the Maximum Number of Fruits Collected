#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n ** 2 * s) complexity by time and O(n ** 2) by space.

I really liked the problem because the idea itself gives something to think about.
Due to the limitations in the number of moves, we know for sure that the central child can only move diagonally, and the two neighboring ones cannot cross it, because then they will not have enough time to return. 
If you implement this without memoization, you can run into TLE. Which is what I did. I was upset, but then I attached the CACHE and everything worked!
"""

class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        max_index = len(fruits) - 1
        changes = {
            "left": [(-1, 1), (0, 1), (1, 1)],
            "right": [(1, -1), (1, 0), (1, 1)],
        }

        @lru_cache(maxsize=None)
        def traverse(y, x, steps_left, is_left):
            if y == x and (y, x) != (max_index, max_index):
                return 0

            if is_left and y <= x:
                return 0
            if not is_left and y >= x:
                return 0

            if steps_left < 0:
                return 0

            if y == x == max_index:
                return fruits[y][x]

            max_fruit = 0
            for dy, dx in changes["left" if is_left else "right"]:
                ny, nx = y + dy, x + dx
                if ny > max_index or nx > max_index or ny < 0 or nx < 0:
                    continue
                if steps_left - 1 == 0 and (ny != max_index or nx != max_index):
                    continue

                max_fruit = max(
                    max_fruit,
                    traverse(ny, nx, steps_left - 1, is_left)
                )

            return fruits[y][x] + max_fruit

        n = len(fruits)

        mid = sum(fruits[i][i] for i in range(n - 1))
        left_down = traverse(max_index, 0, max_index, True)
        right_up = traverse(0, max_index, max_index, False)
        last_cell = fruits[max_index][max_index]

        return left_down + right_up + mid + last_cell


# DP version 
# https://leetcode.com/problems/find-the-maximum-number-of-fruits-collected/editorial/?envType=daily-question&envId=2025-08-07

class Solution:
    def maxCollectedFruits(self, fruits):
        n = len(fruits)
        ans = sum(fruits[i][i] for i in range(n))

        def dp():
            prev = [float("-inf")] * n
            curr = [float("-inf")] * n
            prev[n - 1] = fruits[0][n - 1]
            for i in range(1, n - 1):
                for j in range(max(n - 1 - i, i + 1), n):
                    best = prev[j]
                    if j - 1 >= 0:
                        best = max(best, prev[j - 1])
                    if j + 1 < n:
                        best = max(best, prev[j + 1])
                    curr[j] = best + fruits[i][j]
                prev, curr = curr, prev
            return prev[n - 1]

        ans += dp()

        for i in range(n):
            for j in range(i):
                fruits[i][j], fruits[j][i] = fruits[j][i], fruits[i][j]

        ans += dp()
        return ans
