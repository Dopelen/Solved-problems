#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n * log(n)) complexity by time and O(n * n) by space.

I figured I was really smart and would just need to find a day when I could traverse the matrix from LEFT to RIGHT, and that's basically it, except the timing isn't right; it's O(n ** 2).
The standard logarithmic solution also involves traversals, but with a binary guessing game. 
I know this technique, but I thought the previous solution would work.
"""

# Correct solution
class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        dirs = [(1,0),(-1,0),(0,1),(0,-1)]

        def can_cross(day):
            grid = [[0]*col for _ in range(row)]
            for i in range(day):
                r, c = cells[i]
                grid[r-1][c-1] = 1

            q = deque()
            visited = [[False]*col for _ in range(row)]

            for c in range(col):
                if grid[0][c] == 0:
                    q.append((0, c))
                    visited[0][c] = True

            while q:
                r, c = q.popleft()
                if r == row - 1:
                    return True
                for dr, dc in dirs:
                    nr, nc = r+dr, c+dc
                    if 0 <= nr < row and 0 <= nc < col:
                        if not visited[nr][nc] and grid[nr][nc] == 0:
                            visited[nr][nc] = True
                            q.append((nr, nc))
            return False

        left, right = 1, len(cells)
        ans = 0
        while left <= right:
            mid = (left + right) // 2
            if can_cross(mid):
                ans = mid
                left = mid + 1
            else:
                right = mid - 1
        return ans


# TLE Solution O(n ** 2)
class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        d = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
        adj_matrix = [[0 for —Å in range(col)] for r in range(row)]
        path_is_blocked = False

        def traverse(_y, _x, side, visited):
            nonlocal path_is_blocked
            if adj_matrix[_y][_x] not in [1, side]:
                path_is_blocked = True
                return
            visited.add((_y, _x))
            adj_matrix[_y][_x] = side
            for dy, dx in d:
                ny = _y + dy
                nx = _x + dx
                if (0 <= ny < row) and (0 <= nx < col) and ((ny, nx) not in visited) and (adj_matrix[ny][nx] != 0):
                    traverse(ny, nx, side, visited)

        def side_from_neighbors(s_y, s_x):
            nonlocal path_is_blocked
            for dy, dx in d:
                ny = s_y + dy
                nx = s_x + dx
                if 0 <= ny < row and 0 <= nx < col:
                    if adj_matrix[ny][nx] in [0, 1]:
                        continue
                    else:
                        adj_matrix[s_y][s_x] = adj_matrix[ny][nx]
                        traverse(ny, nx, adj_matrix[ny][nx], set())

        for i in range(len(cells)):
            y = cells[i][0] - 1
            x = cells[i][1] - 1
            adj_matrix[y][x] = 1
            if x in [0, col - 1]:
                traverse(y, x, 2 if x == 0 else 3, set())
            else:
                side_from_neighbors(y, x)
            if path_is_blocked:
                return i
