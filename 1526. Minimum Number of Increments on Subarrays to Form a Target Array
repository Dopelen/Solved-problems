#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n) complexity by time and O(1) by space.

This problem was added to the complex section as humanitarian aid :)
The solution doesn't require knowledge of any specific data structures; you can just figure it out in your head.
The problem itself is cool, but I've found more difficult ones even in the easy section.

The key to the solution is that as the elements increase, we always need to introduce an additional operation to handle this increase, 
so the whole problem boils down to finding the difference in value between the beginning and end of all increasing sublists.

In fact, it's even simpler than it sounds.
"""

class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        required_operations =  target[0]

        for index in range(1, len(target)):
            if target[index] > target[index - 1]:
                required_operations += target[index] - target[index - 1]

        return required_operations
