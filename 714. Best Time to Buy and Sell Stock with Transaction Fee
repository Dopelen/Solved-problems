#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n) complexity by time and O(1) by space.

Even though the problem is classic for dynamic programming, I spent an inordinate amount of time fiddling with it.
I wrote a solution with quadratic complexity, crashed into TLE, and had to rewrite it.
Perhaps lack of sleep is to blame; DP problems are more difficult to understand than usual.
"""

# Greedy O(n) and right
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        hold, cash = -prices[0], 0
        for price in prices[1:]:
            hold = max(hold, cash - price)
            cash = max(cash, hold + price - fee)
        return cash


# initial TLE solution
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        size = len(prices)
        possible_profit = [0] * size
        
        for j in range(1, size):
            for i in range(j):
                current_profit = prices[j] - prices[i] - fee
                if current_profit > 0:
                    if i > 0:
                        current_profit += possible_profit[i - 1]
                    possible_profit[j] = max(current_profit, possible_profit[j])
            possible_profit[j] = max(possible_profit[j], possible_profit[j - 1])
        
        return possible_profit[-1]
