#!/usr/bin/python
"""You can see the description of the task using the code specified in the title on leetcode.
This program has O(n * m) complexity by time and O(n * m) by space.

Some kind of simple and complex task at the same time. 
I solved it head-on and got some kind of nonsense, which, although it passes test cases, works mortally slowly. 
I started looking for optimal solutions, but it seems quite difficult to come up with them.
"""

# A very clever solution O(n * m), not mine. 
# We find the points of mismatch and from there we go left and right, calculating the number of matching characters in each direction. 
# Since we already have 1 mismatch (the starting point), we will stop as soon as we find more than one, and from the resulting coordinates we will calculate how many substrings we can make.

class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        s_size, t_size = len(s), len(t)
        result = 0

        for i in range(s_size):
            for j in range(t_size):
                if s[i] != t[j]:

                    left = 1
                    while i - left >= 0 and j - left >= 0 and s[i - left] == t[j - left]:
                        left += 1

                    right = 1
                    while i + right < s_size and j + right < t_size and s[i + right] == t[j + right]:
                        right += 1

                    result += left * right

        return result


# Actual Solution with difference check O(n ** 2 * m)
class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        result = 0
        s_size, t_size = len(s), len(t)

        for i in range(s_size):
            for j in range(t_size):
                diff = 0
                step = 0

                while i + step < s_size and j + step < t_size and diff <= 1:
                    if s[i + step] != t[j + step]:
                        diff += 1
                    if diff == 1:
                        result += 1
                    step += 1

        return result

# Initial O(n ** 3 * m ** 3) Solution
class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        s_size, t_size = len(s), len(t)
        unique_substrings = defaultdict(int)
        valid_substrings = 0

        for i in range(t_size):
            for j in range(i + 1, t_size + 1):
                unique_substrings[t[i:j]] += 1

        for r in range(s_size):
            for k in range(r + 1, s_size + 1):
                cur_substring = s[r:k]
                for index in range(len(cur_substring)):
                    for symbol in string.ascii_lowercase:
                        changed_string = cur_substring[:index] + symbol + cur_substring[index + 1::]
                        if changed_string != cur_substring:
                            valid_substrings += unique_substrings[changed_string]

        return valid_substrings

